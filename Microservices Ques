Milestones:
1. 12 Factors app
2. External configuration(config server)
3. Data Access(Spring-data-jpa)
4. Actuator
5. Security
6. Asynchronous messaging
7. Testcase
8. Service Broker
9. Transaction handling
10. Deployment
11. Logging
12. Manifest
13. Blue-green deployment
14. Auto-scaling
15. Service broker
16. Service discovery
17. Fault tolerance
18. Exception Handling


1. Profiling
2. multiple datasources in a single microservice
3. Transaction handling in where multiple microservices are called in a same transaction.
4. How to trace the erroneous/faulty microservice in chained mircoservices.
5. Different microservice design patterns(SAGA,aggregator,API Gateway,Asynchronous messaging,Service Discovery)
6. Server side vs client side load balancing
7. Composite primary key in JPA
8. Exception propagation in REST
9. Exception handling in Spring Boot application
10. How to send request header through restTemplate
11. Validation in rest call(while sending wrong value as JSON)
12. What is an Idempotence and where it is used?
13. Where Do We Use WebMVC Test Annotation?
14. Host based routing VS Path based routing
15. Mapstruct, return a merged JSON which is a combination of multiple pojos


Infrastructure:
1. AWS-Kubernetes with HAProxy https://techbeacon.com/devops/one-year-using-kubernetes-production-lessons-learned
2. Kubernetes idea: https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/
3. Difference between AWS ECS and EKS: https://www.missioncloud.com/blog/amazon-ecs-vs-eks-which-service-is-right-for-you/
4. Run Spring boot application excluding embedded tomcat server, using jetty server
5. On-premise database with AWS infrastructure
6. Import/migrate on-premise data to AWS
7. Throttling based on caller application, application based users and traffic limit.
8. Different ways to handle transaction on multiple microservices quering multiple database database

